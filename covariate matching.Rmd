
# Set up

Load packages
```{r}
library(sf)          # Spatial data
library(terra)       # Raster processing  
library(spsurvey)    # Spatially balanced sampling
library(MatchIt)     # Matching
library(cobalt)      # Balance checking
library(tidyverse)       # Data wrangling
library(exactextractr) # Zonal stats
library(rnaturalearth) # Country boundaries
library(tmap)        # Making maps
```

Settings and universal variables
```{r}
tmap_mode(mode = "view")

crs = 4326
crs_dist = 8857

options(scipen=999)
```

# Import data


## List of countries for analysis
```{r}
countries_df = read.csv("Processed data/data_breakdown_by_country_apr30.csv")

countries_full = as.vector(countries_df%>%filter((landmark %in% c("Full Data", "Indicative areas") | in_garnett == "Yes") & (maus_polygons > 0 | snp_points > 0))%>%pull(country))

countries_recog = as.vector(countries_df%>%filter(landmark == "Full Data" & (maus_polygons > 0 | snp_points > 0))%>%pull(country))
```

## Dependent variable
```{r}
snp = st_transform(st_read("Processed data/snp_points_filtered.gpkg"), crs)%>%
  filter(geounit %in% countries_full)

maus = st_transform(st_read("Processed data/maus_polygons_filtered_joined.gpkg"), crs)%>%
  filter(geounit %in% countries_full)%>%
  st_make_valid()
```


## Study area

Define study area (based on adm1). We only want administrative areas that have at least one mine and one Indigenous territory, for both all territories and territories for which we have recognition data.
```{r}
adm1s_full <- st_transform(ne_download(scale = 10, type = "states", category = "cultural", returnclass = "sf"), crs)%>%
  filter(admin %in% countries_full)%>%
  st_make_valid()

adm1_recog = adm1s_full%>%
  filter(admin %in% countries_recog)
  
study_area_adm1s_full = adm1s_full%>%
  filter(lengths(st_intersects(., maus)) > 0 | 
         lengths(st_contains(., snp)) > 0)

study_area_adm1s_recog = adm1_recog%>%
  filter(lengths(st_intersects(., maus)) > 0 | 
         lengths(st_contains(., snp)) > 0)
```

We were unable to filter for areas that intersected with our Indigenous territories layer due to invalid geometries in that layer. We did this in ArcGIS Pro instead (see 'landmark_arcgis') and import back our study area of administrative areas.
```{r}
st_write(study_area_adm1s_full, "Processed data/Study area/study_area_adm1s_full_mines.shp")
st_write(study_area_adm1s_recog, "Processed data/Study area/study_area_adm1s_recog_mines.shp")

rm(adm1s_full)
rm(adm1_recog)

study_area_adm1s_recog = st_read("Processed data/Landmark processed/landmark_recog_clipped_study_area.shp")
```

## Independent variable
```{r}
sf_use_s2(FALSE)

st_layers("C:/Users/benji/Desktop/Landmark/landmark_arcgis/landmark_arcgis.gdb")

landmark = st_transform(st_read(dsn = "C:/Users/benji/Desktop/Landmark/landmark_arcgis/landmark_arcgis.gdb", layer = "community_landmark_singlepart"), crs)%>%
  filter(Country %in% countries_full)%>%
  rename(geometry = Shape)%>%
  mutate(recognition = ifelse(Form_Rec == "Acknowledged by govt" & Doc_Status == "Documented", 1, 0))%>%
  st_make_valid()   

landmark = landmark%>%
  st_filter(., study_area_adm1s_full, .pred = st_intersects)

study_area_adm1s_full = study_area_adm1s_full%>%
  st_filter(., landmark, .pred = st_intersects())

sf_use_s2(TRUE)
```

## Covariates

Road density
```{r}
road_density_raw = rast("Raw data/Covariates/Road access/GRIP4_density_total/grip4_total_dens_m_km2.asc")
road_density = log(road_density_raw + 0.001)
```

Distance to water
```{r}
dist_to_water = rast("Raw data/Covariates/Distance to water/distance_to_water.tif")
```

Nightlights
```{r}
#nightlights = rast("Raw data/Covariates/Nightlights/VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif/VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif")
```

Protected areas
```{r}
protected_areas = st_read("Raw data/Covariates/Protected areas/WDPA_WDOECM_May2025_Public_all/WDPA_WDOECM_May2025_Public_all.gdb", layer = "WDPA_WDOECM_poly_May2025_all")%>%
  st_filter(., study_area_adm1s_full, .pred = st_intersects())
```

Land cover
```{r}
land_cover_path = "Raw data/Covariates/Land cover/MCD12C1.A2023001.061.2024251212901.hdf"
gdal_subdatasets(land_cover_path)

land_cover = rast(land_cover_path, subds = "Majority_Land_Cover_Type_1")

forest_binary = as.numeric(land_cover %in% 1:5)  # Classes 1-5 are forest types (Evergreen Needleleaf to Mixed Forests)
cropland_binary = as.numeric(land_cover %in% c(12,14)) # Class 12 is cropland, 14 is cropland mosaic

plot(forest_binary)
plot(cropland_binary)
```


USGS ECM deposits
```{r}
usgs_deposits = st_transform(st_read("Processed data/usgs_deposits_filtered.gpkg"), crs)%>%
  filter(geounit %in% countries_full)
```

Population Density
```{r}
pop_dens = rast("Raw data/Covariates/Population density/gpw_v4_population_density_rev11_2020_30_sec_2020.tif")
```


# Generate spatially balanced points

Option A: Stratified by mine proximity (using spsurvey)
```{r}
deposit_buffers$stratum = ifelse(
  st_distance(deposit_buffers, mines) <= 10000, 1, 0  # 10km threshold
)

set.seed(42)
samples = grts(
  sf_object = deposit_buffers,
  n_base = c(1000, 1000),  # Adjust based on your needs
  stratum_var = "stratum"
)
sampled_points = st_as_sf(samples$sites_base)
```

Option B: Halton sequence (uniform random)
```{r, eval = F}
sampled_points = st_halton(2000, crs = st_crs(deposit_buffers)) %>%
  st_as_sf() %>%
  st_intersection(deposit_buffers)
```

# Extract covariates

NEED TO CALCULATE DISTANCE TO NEAREST USGS DEPOSIT POINT
```{r}
# Continuous variables
sampled_points = sampled_points %>%
  mutate(
    road_density = extract(road_density, vect(.))[,2],
    pop_density = extract(pop_density, vect(.))[,2],
    dist_water = extract(dist_water, vect(.))[,2],
    near_mine = st_distance(., mines) <= 10000)

# Land cover classification
lc_reclass = classify(landcover, 
  matrix(c(10,1, 20,2, 30,2), ncol=2, byrow=TRUE))

sampled_points$forest_cover = extract(
  lc_reclass == 1, vect(sampled_points), buffer=1000, fun=mean, na.rm=TRUE)[,2]

sampled_points$farmland_cover = extract(
  lc_reclass == 2, vect(sampled_points), buffer=1000, fun=mean, na.rm=TRUE)[,2]

# Protected areas
sampled_points$protected = as.numeric(
  st_intersects(sampled_points, protected_areas, sparse=FALSE))

# Add country info
sampled_points = st_join(sampled_points, countries)
```

# Matching

```{r}
# Define treatment variables
sampled_points = sampled_points %>%
  mutate(
    indigenous = as.numeric(st_intersects(., indigenous_lands, sparse=FALSE)),
    recognized = as.numeric(st_intersects(., recognized_lands, sparse=FALSE))
  )

# Create control pool
control_pool = filter(sampled_points, indigenous == 0)
```

```{r}
match_recog = matchit(
  recognized ~ road_density + pop_density + dist_water +
               forest_cover + farmland_cover + protected,
  data = bind_rows(
    filter(sampled_points, recognized == 1),
    control_pool
  ),
  method = "nearest",
  exact = ~ country,
  caliper = 0.2,
  ratio = 3
)

matched_recog = match.data(match_recog)
```

Balance checking
```{r}
# Recognized lands balance
bal.tab(match_recog, stats = c("mean.diffs", "ks.statistics"))
love.plot(match_recog, threshold = 0.1, abs = TRUE)

# Non-recognized lands balance  
bal.tab(match_nonrecog, stats = c("mean.diffs", "ks.statistics"))
love.plot(match_nonrecog, threshold = 0.1, abs = TRUE)
```

# Analysis
```{r}
# Add outcome variable
matched_recog = matched_recog %>%
  mutate(mine_outcome = as.numeric(near_mine))

matched_nonrecog = matched_nonrecog %>%
  mutate(mine_outcome = as.numeric(near_mine))

# Recognized lands model
model_recog = glm(
  mine_outcome ~ recognized + road_density + pop_density +
                forest_cover + farmland_cover + factor(country),
  data = matched_recog,
  family = binomial()
)

# Non-recognized lands model
model_nonrecog = glm(
  mine_outcome ~ indigenous + road_density + pop_density +
                forest_cover + farmland_cover + factor(country), 
  data = matched_nonrecog,
  family = binomial()
)

# Compare results
summary(model_recog)
summary(model_nonrecog)
```

