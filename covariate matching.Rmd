
# Set up

Load packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
    library(sf)          # Spatial data
  library(terra)       # Raster processing  
  library(spsurvey)    # Spatially balanced sampling
  library(MatchIt)     # Matching
  library(cobalt)      # Balance checking
  library(tidyverse)       # Data wrangling
  library(exactextractr) # Zonal stats
  library(rnaturalearth) # Country boundaries
  library(tmap)        # Making maps
  })})
```

Settings and universal variables
```{r}
tmap_mode(mode = "view")

crs = 4326
crs_dist = 8857

options(scipen=999)
```

# Import data

## List of countries for analysis
```{r, eval = F}
countries_df = read.csv("Processed data/data_breakdown_by_country_apr30.csv")

countries_full = as.vector(countries_df%>%filter((landmark %in% c("Full Data", "Indicative areas") | in_garnett == "Yes") & (maus_polygons > 0 | snp_points > 0))%>%pull(country))

countries_recog = as.vector(countries_df%>%filter(landmark == "Full Data" & (maus_polygons > 0 | snp_points > 0))%>%pull(country))
```

## Study area

Define study area (based on adm1). We only want administrative areas that have at least one mine and one Indigenous territory, for both all territories and territories for which we have recognition data.
```{r, eval = F}
adm1s_full <- st_transform(ne_download(scale = 10, type = "states", category = "cultural", returnclass = "sf"), crs)%>%
  filter(admin %in% countries_full)%>%
  st_make_valid()

adm1_recog = adm1s_full%>%
  filter(admin %in% countries_recog)
  
study_area_adm1s_full = adm1s_full%>%
  filter(lengths(st_intersects(., maus)) > 0 | 
         lengths(st_contains(., snp)) > 0)

study_area_adm1s_recog = adm1_recog%>%
  filter(lengths(st_intersects(., maus)) > 0 | 
         lengths(st_contains(., snp)) > 0)
```

We were unable to filter for areas that intersected with our Indigenous territories layer due to invalid geometries in that layer. We did this in ArcGIS Pro instead (see 'landmark_arcgis') and import back our study area of administrative areas.
```{r, eval = F}
st_write(study_area_adm1s_full, "Processed data/Study area/study_area_adm1s_full_mines.shp")
st_write(study_area_adm1s_recog, "Processed data/Study area/study_area_adm1s_recog_mines.shp")

rm(adm1s_full)
rm(adm1_recog)
```

```{r}
study_area_adm1s_recog = st_transform(st_read("Processed data/Study area/study_area_adm1s_recog.shp"), crs)
study_area_adm1s_full = st_transform(st_read("Processed data/Study area/study_area_adm1s_full.shp"), crs)
```


## Dependent variable (mines)
```{r}
snp = st_transform(st_read("Processed data/snp_points_filtered.gpkg"), crs)%>%
  filter(lengths(st_intersects(., study_area_adm1s_full)) > 0)

maus = st_transform(st_read("Processed data/maus_polygons_filtered_joined.gpkg"), crs)%>%
  st_make_valid()%>%
  filter(lengths(st_intersects(., study_area_adm1s_full)) > 0)
```



## Independent variable (Landmark)

Load in our landmark datasets of Indigenous territories
```{r, eval = F}
landmark_study_area_full = st_read("Processed data/Landmark processed/landmark_and_garnett_full_study_area.shp")

landmark_study_area_recog = st_read("Processed data/Landmark processed/landmark_recog_study_area.shp")
```



## Covariates

Road density
```{r}
road_density_raw = rast("Raw data/Covariates/Road access/GRIP4_density_total/grip4_total_dens_m_km2.asc")
road_density = log(road_density_raw + 0.001)

rm(road_density)
```

Distance to water
```{r}
dist_to_water = rast("Raw data/Covariates/Distance to water/distance_to_water.tif")
```

Nightlights
```{r}
#nightlights = rast("Raw data/Covariates/Nightlights/VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif/VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif")
```

Protected areas
```{r}
protected_areas_full = st_read("Raw data/Covariates/Protected areas/protected_areas_study_area_full.shp")
```

Land cover
```{r}
land_cover_path = "Raw data/Covariates/Land cover/MCD12C1.A2023001.061.2024251212901.hdf"
gdal_subdatasets(land_cover_path)

land_cover = rast(land_cover_path, subds = "Majority_Land_Cover_Type_1")

forest_binary = as.numeric(land_cover %in% 1:5)  # Classes 1-5 are forest types (Evergreen Needleleaf to Mixed Forests)
cropland_binary = as.numeric(land_cover %in% c(12,14)) # Class 12 is cropland, 14 is cropland mosaic

plot(forest_binary)
plot(cropland_binary)

rm(land_cover)
```


## USGS ECM deposits
```{r}
usgs_deposits = st_transform(st_read("Processed data/usgs_deposits_filtered.gpkg"), crs)%>%
  filter(lengths(st_intersects(., study_area_adm1s_full)) > 0)
```

Population Density
```{r}
pop_dens = rast("Raw data/Covariates/Population density/gpw_v4_population_density_rev11_2020_30_sec_2020.tif")
```


# Spatially balanced sample

## Descriptives

Calculate area breakdown by 'recognition' type
```{r}
landmark_overlap = landmark_recog_clipped_study_area %>%
  st_make_valid()%>%
  mutate(area = st_area(.)) %>%  # Area of each landmark polygon
  group_by(recognition)%>%      
  summarize(
    total_area = sum(area),      # Total area per recognition type
    perc_of_study_area = as.numeric(total_area / st_area(study_area_adm1s_recog)) * 100)

landmark_overlap
```



## Generate spatially balanced points
Option A: Stratified by mine proximity (using spsurvey)
```{r}
deposit_buffers$stratum = ifelse(
  st_distance(deposit_buffers, mines) <= 10000, 1, 0  # 10km threshold
)

set.seed(42)
samples = grts(
  sf_object = deposit_buffers,
  n_base = c(1000, 1000),  # Adjust based on your needs
  stratum_var = "stratum"
)
sampled_points = st_as_sf(samples$sites_base)
```

Option B: Halton sequence (uniform random)
```{r, eval = F}
sampled_points = st_halton(2000, crs = st_crs(deposit_buffers)) %>%
  st_as_sf() %>%
  st_intersection(deposit_buffers)
```

# Extract covariates

NEED TO CALCULATE DISTANCE TO NEAREST USGS DEPOSIT POINT
```{r}
# Continuous variables
sampled_points = sampled_points %>%
  mutate(
    road_density = extract(road_density, vect(.))[,2],
    pop_density = extract(pop_density, vect(.))[,2],
    dist_water = extract(dist_water, vect(.))[,2],
    near_mine = st_distance(., mines) <= 10000)

# Land cover classification
lc_reclass = classify(landcover, 
  matrix(c(10,1, 20,2, 30,2), ncol=2, byrow=TRUE))

sampled_points$forest_cover = extract(
  lc_reclass == 1, vect(sampled_points), buffer=1000, fun=mean, na.rm=TRUE)[,2]

sampled_points$farmland_cover = extract(
  lc_reclass == 2, vect(sampled_points), buffer=1000, fun=mean, na.rm=TRUE)[,2]

# Protected areas
sampled_points$protected = as.numeric(
  st_intersects(sampled_points, protected_areas, sparse=FALSE))

# Add country info
sampled_points = st_join(sampled_points, countries)
```

# Matching

```{r}
# Define treatment variables
sampled_points = sampled_points %>%
  mutate(
    indigenous = as.numeric(st_intersects(., indigenous_lands, sparse=FALSE)),
    recognized = as.numeric(st_intersects(., recognized_lands, sparse=FALSE))
  )

# Create control pool
control_pool = filter(sampled_points, indigenous == 0)
```

```{r}
match_recog = matchit(
  recognized ~ road_density + pop_density + dist_water +
               forest_cover + farmland_cover + protected,
  data = bind_rows(
    filter(sampled_points, recognized == 1),
    control_pool
  ),
  method = "nearest",
  exact = ~ country,
  caliper = 0.2,
  ratio = 3
)

matched_recog = match.data(match_recog)
```

Balance checking
```{r}
# Recognized lands balance
bal.tab(match_recog, stats = c("mean.diffs", "ks.statistics"))
love.plot(match_recog, threshold = 0.1, abs = TRUE)

# Non-recognized lands balance  
bal.tab(match_nonrecog, stats = c("mean.diffs", "ks.statistics"))
love.plot(match_nonrecog, threshold = 0.1, abs = TRUE)
```

# Analysis
```{r}
# Add outcome variable
matched_recog = matched_recog %>%
  mutate(mine_outcome = as.numeric(near_mine))

matched_nonrecog = matched_nonrecog %>%
  mutate(mine_outcome = as.numeric(near_mine))

# Recognized lands model
model_recog = glm(
  mine_outcome ~ recognized + road_density + pop_density +
                forest_cover + farmland_cover + factor(country),
  data = matched_recog,
  family = binomial()
)

# Non-recognized lands model
model_nonrecog = glm(
  mine_outcome ~ indigenous + road_density + pop_density +
                forest_cover + farmland_cover + factor(country), 
  data = matched_nonrecog,
  family = binomial()
)

# Compare results
summary(model_recog)
summary(model_nonrecog)
```

